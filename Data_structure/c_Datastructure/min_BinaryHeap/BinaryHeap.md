二叉堆(又叫堆) 本身逻辑上是一颗完全二叉树
物理上是一个数组
作用:找数据中的最值
二叉堆中任意节点的值大于(小于)左右孩子结点的值
大堆和小堆
 



已知[parent]
[left]=2*[parent]+1;
[right]=2*[parent]+2;

已知[child](无论左右)
[parent]=([child-1])/2

堆的向下调整过程
要调整的结点下标是[root]
[root] 左右子树已经满足堆的性质
【假如是小堆】
1.要调整[root] 所在的结点
  前提：[root] 的左右子树已经满足堆的性质
  如果root所在的结点已经是叶子结点，调整结束
2.找到左右孩子中最小的一个结点[min]
  需要考虑右孩子是否有问题
3.if(array[min] > array[root])
  不需要继续调整,调整结束
  else 
    Swap(&array[root].&array[min])
4.以min做为root继续向下调i整

向下调整的时间复杂度为O(logN)



### 向上调整
[child]  为调整的目标结点
1.判断[child] 是不是整棵树的根节点 ==0
  如果是 调整结束
2.array[child] > array[parent]
   满足条件 调整结束
3.交换array[parent] 与array[child]
4.以parent 做为 child 继续向上调整

建堆 O(N) O(nlogn)
  假如除了根节点,左右子树都已经满足了堆的性质
  直接对根节点进行向下调整

  因为假设条件不成立,所以徐娅相对左右两个子树建堆

  从下往上依次建堆[先从最后一个非叶子结点开始]
  for(int i=(size-2)/2;i>0:i--){}
  size为数组的规模,size-1 为数组的最后一个元素的下标
  size-2/2  是最后一个结点的双亲结点

堆排序 
  排升序:建大堆 
  topK  建小堆  找最大的K个数




